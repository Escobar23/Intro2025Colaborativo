    // parcela = celda
    // mapa = tablero
    // recursos = colores
    // sector = parcela actual y lindantes


    //puntos a obtener por alimento u oro
    //puntos a obtener por madera o piedra
    // plus por tener todos






    function puntosAObtenerEnSector() {
        /*
        prop: describe los puntos obtenidos en el sector centrado en la parcela actual
        prec: ninguna
        tipo: numero
        */

        return(puntos_AObtenerSiHayRecurso_O_EnElSector(15,recursoOro(), recursoAlimento()) + 
            puntos_AObtenerSiHayRecurso_O_EnElSector(10,recursoMadera(), recursoPiedra()) 
            + puntos_AdicionalesPorHaberTodosLosRecursosEnElSector(10))

    }


    function puntos_AObtenerSiHayRecurso_O_EnElSector(puntos, primerRecurso, segundoRecurso) {
        /*
        prop:describe los "puntos" puntos a obtener si hay recurso "primerRecurso" o recurso "segundoRecurso" en el sector
        prec: ninguna
        tipo: numero
        param:
        puntos: Numero - numero que describe los puntos a obtener si hay alguno de los recursos
        primeRecurso: Color - color que describe el primerRecurso a evaluar
        segundoRecurso: Color - color que describe el segundoRecurso a evaluar
        obs:
        */

        return(choose puntos when hayRecurso_EnSector(primerrecurso) || hayRecurso_EnSector(segundoRecurso))
    }

    function hayRecurso_EnSector(unRecurso) {
        /*
        prop: indica si en el sector hay recurso "unRecurso" en el sector
        prec: ninguna
        tipo: booleano
        param:
        unRecurso: Color - describe el color que representa el recurso a evaluar
        */

        return(hayRecurso_Aca(unRecurso) || hayRecurso_EnLindantes(unRecurso)
    }

    function hayRecurso_EnLindantes(unRecurso) {
        /*
        prop: indica si en las parcelas lindantes hay recurso "UnRecurso"
        prec: ninguna
        tipo: booleano
        param: 
        unRecurso: Color - describe el color que representa el recurso a evaluar
        obs: es un recorrido de busqueda sin saber si lo que busco esta, sobre direcciones para saber si en las parcelas lindantes 
        ortogonales a la parcela actual, hay el recurso dado
        */

        direccionActual:=minDir()
        while(direccionActual/=maxDir() && not hayRecurso_Al_(unRecurso,direccionActual)) {
            direccionActual:=siguiente(direccionActual)
        }
        return(hayRecurso_Al_(unRecurso,direccionActual))
        
    }

    function hayRecurso_Al_(unRecurso,direccion) {
        /*
        prop: describe si hay un recurso "unRecurso" en la direccion "direccion"
        prec: ninguna
        tipo: booleano
        param:
        */

        return(puedoMover(direccion) && hayRecurso_EnLindanteAl_(unRecurso,direccion))


    }

    function hayRecursoEnLindante(unRecurso,direccion) {
        /*
        prop: indica si hay un recurso "unRecurso" en la direccion lindante al "direccion"
        prec: ninguna
        tipo: booleano
        param:
        unRecurso: Color - color que describe el recurso a evaluar
        direccion: Direccion - direccion lindante a evaluar*/


        mover(direccion)
        return(hayRecurso_Aca())
    }



    function puntos_AdicionalesPorHaberTodosLosRecursosEnElSector(unNumero) {
        /*
        prop: describe "unNumero" puntos adicionales a obtener por tener todos los recursos en el sector de lo contrario devuelve 0
        prec: ninguna
        tipo: numero
        param:
        unNumero: Numero - numero que describe la cantidad de puntos a obtener por tener todos los recursos
        */


        return(choose unNumero when hayTodosLosRecursosEnElSector())
            0 otherwise)


    }

    function hayTodosLosRecursosEnElSector(){
        /*
        prop: indica si estan todos los recursos en el sector actual
        prec: ninguna
        tipo: booleano
        */

        return(hayRecurso_EnSector(recursoOro()) && hayRecurso_EnSector(recursoAlimento()) && hayRecurso_EnSector(recursoPiedra()) 
            && hayRecurso_EnSector(recursoMadera())


    }

    function recursoConMenorRiqueza() {
        /*
        prop: describe el recurso con menor riqueza en el mapa
        prec: ninguna
        tipo: Color
        obs: es un recorrido de maximo minimo entre recursos de un mapa para saber cual es el recurso con menor riquesa
        */
    }


    recursoActual := minRecurso()
    recursoConMenorRiquezaHastaAhora:= recursoActual
    while (recursoActual/=maxRecurso()) {
    recursoActual:= siguiente(recursoActual)
    recursoConMenorRiquezaHastaAhora := recursoConMenorRiquesaEntre_Y_(recursoConMenorRiquezaHastaAhora, recursoActual)
    }
    return ( recursoConMenorRiquezaHastaAhora )



    function recursoConMenorRiquesaEntre_Y_(primerRecurso,segundoRecurso) {
        /*
        prop:describe el menor recurso entre "primerRecurso" y "segundoRecurso"
        prec: uno debe ser menor que el otro, en caso de ser iguales retorna el primero
        tipo: Color
        param:
        primerRecurso: Color - color que describe el primer recurso a evaluar
        segundoRecurso: Color - color que describe el segundo recurso a evaluar
        */


        return(choose primerRecurso when intensidadDeRecurso_(primerRecurso) < intensidadDeRecurso_(segundoRecurso),
            segundoRecurso when intensidadDeRecurso_(primerRecurso) > intensidadDeRecurso_(segundoRecurso)
            primerRecurso otherwise)
    }

    