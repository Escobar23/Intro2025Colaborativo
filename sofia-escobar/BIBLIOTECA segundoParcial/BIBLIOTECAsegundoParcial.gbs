//Segundo Parcial Biblioteca
function laLista_Ordenada(lista){
    /*
    PROPÓSITO: Describe una nueva lista con los elementos de **listaDeNúmeros** ordenados de menor a mayor.
    PRECONDICIÓN: Ninguna.
    PARÁMETROS:
        - listaDeNúmeros: Lista de Número.
    TIPO: Lista de Número.
    OBS: Es un recorrido de transformación sobre números de una listaDeNúmeros generando el orden de menor a mayor.
    */

    listaPorOrdenar := listaDeNúmeros
    listaOrdenada := []

    while(not esVacía(listaPorOrdenar)){
        númeroMínimo := minimoElementoEn_(listaPorOrdenar)
        listaOrdenada := listaOrdenada ++ [númeroMínimo]
        listaPorOrdenar := elementosEn_SinPrimeraApariciónDe_(listaPorOrdenar, númeroMínimo)
    }

    return(listaOrdenada)
}

function estáOrdenada_(lista){
     /*PROPOSITO: Indicar si la lista **listaDeNúmero** esta ordenada de menor a mayor
      PRECONDICION: **listaDeNúmero** - Lista de Número
      TIPO: Booleano.
      OBS: Es un recorrido de búsqueda sobre números de una lista de número para saber si esta ordenada.
    */
    númerosPorVer := listaDeNúmero
    while(not esVacía(resto(númerosPorVer)) && primero(númerosPorVer) <= primero(resto(númerosPorVer))){
        númerosPorVer := resto(númerosPorVer)
    }
    return(esVacía(resto(númerosPorVer)))
}

function sinDuplicados_(lista){
     /*PROPOSITO: Describe la lista **unaListaDeElementos** sin duplicados. 
      PRECONDICION:  Ninguna. 
      PARAMETROS: **unaListaDeElementos** - Lista de Elemento.
      TIPO: Lista de Elemento.
      OBS: es un Recorrido de transformacion sobre elemento de una lista de elemento para quitar todos los elementos con duplicados.
    */
    resultadoHastaAhora := []
    elementosPorVer := unaListaDeElementos
    foreach elemento in unaListaDeElementos{
        resultadoHastaAhora := resultadoHastaAhora ++ singular_Si_(primero(elementosPorVer), not contiene_A_(resultadoHastaAhora, primero(elementosPorVer)))
        elementosPorVer := resto(elementosPorVer)
    }
    return(resultadoHastaAhora)
}

function elementosEn_SinPrimeraApariciónDe_(lista, elementoAExcluir){
    /*
    Proposito: Describe la lista dada sin la primera aparición del elemento a excluir.
    Precondicion: Ninguna
    Parametro: lista: Lista de Elementos
                elementoAExcluir: Elemento
    Tipo: Lista de Elementos
    */
    listaPorAhora:[]
    while(listaPorAhora/=lista){
        listaHastaAhora:=  listaHastaAhora ++ [primero(lista)]
        lista:= resto(lista)
    }
    return(listaPorAhora)
}

function elementosEn_DespuésDe_(lista, índiceInicio){
    /**/
}

function elementosEn_Desde_(lista, índiceInicio){
   /*PROPOSITO: Describe la lista de todos los elementos de lista **listaDeElementos** desde el indice **unIndice**
    PRECONDICION: Ninguna. 
    PARAMETROS: **listaDeElementos** - Lista de Elementos.
                 **unIndice** - Número
    TIPO: Lista de Elementos. 
    OBS: Es un recorrido de transformacion sobre elementos de una lista de elementos para devolver la lista de elementos desde el indice dado.
    */
    númeroDelIndiceHastaAhora := 0
    elementosDesdeElIndice := []
    foreach elemento in listaDeElementos{
        númeroDelIndiceHastaAhora := númeroDelIndiceHastaAhora + 1
        elementosDesdeElIndice := elementosDesdeElIndice ++ singular_Si_(elemento, (númeroDelIndiceHastaAhora >= unIndice)) 
    }
    return(elementosDesdeElIndice)
}



function elementosEn_AntesDe_(lista, índiceFin){
    /*
    Proposito:Describe la lista *lista* antes del índice *índiceFin*,sin incluir el elemento en dicho índice.
    Precondicion: El índice *índiceFin* debe ser mayor o igual a 0
    Parametro: lista: Lista de Elementos
                índiceFin: Número
    Tipo: Lista de Elementos
    */

}

function elementosEn_Hasta_(lista, índice){
    /*PROPOSITO:Describe la lista de todos los elementos en la lista **listaDeElementos** hasta el indice **unIndice**
    PRECONDICION: Ninguna. 
    PARAMENTROS: **listaDeElementos** - Lista de Elementos.
                 **unIndice** - Número
    TIPO: Lista de Elementos.
    OBS: Es un recorrido de Transformacion sobre elementos de una Lista de Elementos para devolver la lista de elementos hasta el indice dado. 
    */
    elementosVistos := 0
    elementosVistosHastaAhora := []
    elementosPorVer := listaDeElementos
    while(not esVacía(elementosPorVer) && not (elementosVistos == unIndice)){
        elementosVistosHastaAhora := elementosVistosHastaAhora ++ [primero(elementosPorVer)]
        elementosPorVer := resto(elementosPorVer)
        elementosVistos := elementosVistos + 1
    }
    return(elementosVistosHastaAhora)
}

function máximoElementoEn_(lista){
    /*
    Proposito: Describe el número máximo de la lista dada.
    Precondicion: La lista no es vacía.
    Parametro: lista: Lista de Números
    Tipo: Número
    */
    máximoActual:=primero(lista)
    foreach elemento in resto(lista){
        máximoActual:= singular_Si_(elemento, elemento > máximoActual)
    }
    return(máximoActual)
}

function minimoElementoEn_(lista){
    /*
    Proposito: Describe el número mínimo de la lista dada.
    Precondicion: La lista no es vacía.
    Parametro: lista: Lista de Números
    Tipo: Número
    */
    mínimoActual:=primero(lista)
    foreach elemento in resto(lista){
        mínimoActual:= singular_Si_(elemento, elemento < mínimoActual)
    }
    return(mínimoActual)
}

//importante
function indiceEn_De_(lista, elemento){
    /*
    Proposito: Indica el índice de la primera aparición del elemento *elemento* en la lista *lista*.
    Precondicion: El elemento *elemento* debe estar en la lista *lista*
    Parametro: lista: Lista de Elementos
                elemento: Elemento
    Tipo: Número
    Obs: Es un recorrido de búsqueda sobre elementos de una lista buscando el elemento *elemento
    */
    índiceActual:=0
    listaRestante:=lista
    while(primero(listaRestante) /= elemento){
        índiceActual:= índiceActual + 1
        listaRestante:= resto(listaRestante)   
    }
    return(índiceActual)
}

//importante
function contiene_A_(lista, elemento){
    /*
    Proposito: Indica si la lista *lista* contiene el elemento *elemento*.
    Precondicion: Ninguna
    Parametro: lista: Lista de Elementos
                elemento: Elemento
    Tipo: Booleano
    Obs: Es un recorrido de busqueda sobre elementos de una lista buscando el elemento *elemento*
    */
    listaRestante := lista
    while(not esVacía(listaRestante)&&primero(listaRestante) /= elemento){
        listaRestante := resto(listaRestante)
    }
    return(?)
}

function elementosDe_SinAparicionesDe_(lista, elementoAExcluir){
    /*
    Proposito: Describe la lista dada sin las apariciones del elemento a excluir.
    Precondicion: Ninguna
    Parametro: lista: Lista de Elementos
                elementoAExcluir: Elemento  
    Tipo: Lista de Elementos
    */
    listaPorAhora:[]
    foreach elemento in lista{
        listaPorAhora:= listaPorAhora ++ singular_Si_(elemento, elemento /= elementoAExcluir)  
    }
    return(listaPorAhora)
}

function reversoDe_(lista){
    /*
    Proposito: Describe la lista inversa de la dada.
    Precondicion: Ninguna
    Parametro: lista: Lista de Elementos
    Tipo: Lista de Elementos
    */
    listaPorAhora:[]
    foreach elemento in lista{
        listaPorAhora:= [elemento] ++ listaPorAhora 
    }
    return(listaPorAhora)
}

//importante   
function siguientesDe_(lista){
    /*
    Proposito: Describe la lista donde cada elemento es el siguiente del dado.
    Precondicion: Ninguna
    Parametro: lista: Lista de Elementos
    Tipo: Lista de Elementos
    */
    listaPorAhora:[]
    foreach elemento in lista{
        listaPorAhora:=listaPorAhora ++ [siguienteDe_(elemento)]
    }
    return(listaPorAhora)
}

function opuestasDe_(listaDeDirecciones){
    /*
    Proposito: Describe la lista donde cada dirección es la opuesta del dado.
    Precondicion: Ninguna
    Parametro: listaDeDirecciones: Lista de Direcciones
    Tipo: Lista de Direcciones
    */
    listaPorAhora:[]
    foreach dirección in listaDeDirecciones{
        listaPorAhora:=listaPorAhora ++ [opuesto(dirección)]
    }
    return(listaPorAhora)
}

function productoriaDe_(lista){
    /*
    Proposito: Describe el producto de todos los elementos de la lista dada.
    Precondicion: Ninguna
    Parametro: lista: Lista de Números
    Tipo: Número
    */
    producto:=0
    foreach elemento in lista{
        producto:=producto * elemento
    }
    return(producto)
}

function sumatoriaDe_(lista){
    /*
    Proposito: Describe la suma de todos los elementos de la lista dada.
    Precondicion: Ninguna
    Parametro: lista: Lista de Números
    Tipo: Número
    */
    suma:=0
    foreach elemento in lista{
        suma:=suma + elemento
    }
    return(suma)
}

function longitudDe_(lista){
    /*
    Proposito: Indica la cantidad de elementos que tiene la lista dada.
    Precondicion: Ninguna
    Parametro: lista: Lista de Elementos
    Tipo: Número
    */
    contador:=0
    foreach elemento in lista{
        contador:=contador + 1
    }
    return(contador)
}

//importaante
function singular_Si_(elemento, booleano){
    /*
    Proposito: Describe una lista que tiene un solo elemento si el booleano es verdadero, y una lista vacía si el booleano es falso.
    Precondicion: Ninguna
    Parametro: elemento: Elemento
                booleano: Booleano
    Tipo: Lista de Elementos
    */
    return(choose singularCon_(elemento) when (booleano) [] otherwise)
}

function listaDesde_Hasta_(elementoInicio, elementoFin){
    /*
    Proposito: describe una lista con que tiene tantos elementos como el número dado, en donde cada elemento es el dado.
    Precondicion: elementoFin debe ser mayor o igual a elementoInicio
    Parametro: elementoInicio: Elemento
                elementoFin: Elemento
    Tipo: Lista de Elementos
    */
    listaPorAhora:=[]
    contadorDeElementos:=elementoInicio
    while(contadorDeElementos /= elementoFin){
        listaPorAhora:= listaPorAhora ++ [siguiente(contadorDeElementos)]
        contadorDeElementos:=siguienteDe_(contadorDeElementos)
    }
    return(listaPorAhora)
}

function  listaCon_Repetido_Veces(elemento, número){
    /*
    Proposito:  Describe una lista que tiene tantos elementos como el número *número*, cada elemento es *elemento*.
    Precondicion: número debe ser mayor a 0
    Parametro: elemento: Elemento
               número: Número
    Tipo: Lista de Elementos
    */
    lista:=[]
    repeat(número){
        lista:=lista ++ [elemento]
    }
    return(lista)
}  

function esSingular_(lista){
    /*
    Proposito:  Indica sí la lista es singular.
    Precondicion: Ninguna
    Parametro: Lista: Lista de Elementos
    Tipo: Booleano
    */
    return(not esVacía(lista)&&esVacía(resto(lista)))
}
