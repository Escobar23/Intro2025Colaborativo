program{
    IrHastaElMotoqueroSinClubConVecinoEn_(3)
}

//Ejercicio 1
function cantidadDeClubesEnLaConvencion(){
    /*
    Proposito: indica la cantidad de clubes diferentes que hay en la convención de motoqueros.
    Precondiciones: Ninguna.
    Tipo: Entero
    Obs: Es un recorrido de busqueda sobre las celdas de la convención contando los clubes diferentes.
    */
    cantidadDeClubes:=0
    while(hayMotoquerosSinClub()){
        IrAMotoqueroSinClub()
        cantidadDeClubes:=cantidadDeClubes+1
        AsignarClub_AMotoquerosConectados(cantidadDeClubes)
    }
    return(cantidadDeClubes)
}

//c
procedure AsignarClub_AMotoquerosConectados(númeroDeClub){
    /*
    Proposito: asigna un club a todos los motoqueros conectados al motoquero sin club de la ubicacion actual.
    Precondiciones: el cabezal debe estar posicionado en un motoquero sin club
    Obs: Es un recorrido de transformacion sobre las ubicaciones de la convención asignando el club indicado a los motoqueros conectados al motoquero sin club de la ubicacion actual.
    */
    IncluirEnElClubNúmero_(númeroDeClub)
    IrAPrimerMotoqueroAl_YAl_(Norte,Este)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Norte,Este)){
        AsignarClub_AMotoqueroAca(númeroDeClub)
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte,Este)
    }
}

procedure AsignarClub_AMotoqueroAca(númeroDeClub){
    /*
    Proposito: asigna un club al motoquero en la ubicacion actual si no pertenece a ningún club.
    Precondiciones: Ninguna
    */
    if(hayMotoqueroVecinoDeMotoqueroDelClub_(númeroDeClub)){
        IncluirEnElClubNúmero_(númeroDeClub)
    }
}
function hayMotoqueroVecinoDeMotoqueroDelClub_(númeroDeClub){
    /*
    Proposito: indica si hay un motoquero en la ubicacion actual y tiene un vecino que pertenece al club indicado.
    Precondiciones: Ninguna.
    Tipo: Booleano
    */
    return(hayMotoqueroAcá()&&esVecinoDeMotoqueroDelClub(númeroDeClub))
}

function esVecinoDeMotoqueroDelClub(númeroDeClub){
    /*
    Proposito: indica si alguno de los motoqueros vecinos pertenece al club indicado.
    Precondiciones: Ninguna.
    Tipo: Booleano
    Obs: Es un recorrido de busqueda sobre las direcciones buscando un motoquero del club indicado en alguna direccion lindante.
    */
    dirActual:=minDir()
    while(dirActual/=maxDir() && not(hayVecinoEn_DelClub_(dirActual,númeroDeClub))){
        dirActual:=siguienteDir(dirActual)
    }
    return(hayVecinoEn_DelClub_(dirActual,númeroDeClub))
}

function hayVecinoEn_DelClub_(dir,númeroDeClub){
    /*
    Proposito: indica si el vecino en la dirección indicada pertenece al club indicado.
    Precondiciones: Ninguna.
    Tipo: Booleano
    */
    return(puedeMover(dir)&&esVecinoEn_DelClub_(dir,númeroDeClub))
}

function esVecinoEn_DelClub_(dir,númeroDeClub){
    /*
    Proposito: indica si el vecino en la dirección indicada pertenece al club indicado.
    Precondiciones: Tiene que haber al menos una ubicacion en la dirección indicada.
    Tipo: Booleano
    */
    Mover(dir)
    return(hayMotoqueroAcá()&&elMotoqueroPerteneceAlClubNúmero_(númeroDeClub))
    
}
function elMotoqueroPerteneceAlClubNúmero_(númeroDeClub){
    /*
    Proposito: indica si el motoquero en la ubicacion actual pertenece al club indicado.
    Precondiciones: Debe haber un motoquero en la posicion actual.
    Tipo: Booleano
    */  
    return(elMotoqueroPerteneceAUnClub()&&clubAlQuePerteneceUnMotoquero()==númeroDeClub)

//b
procedure IrAMotoqueroSinClub(){
    /*
    Proposito: se posiciona en un motoquero sin club
    Precondiciones: debe haber al menos un motoquero sin club
    Obs: Es un recorrido de busqueda sobre ubicacion de la convencion buscando al motoquero sin club.
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte,Este)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Norte,Este)&&not (hayMotoqueroSinClubAcá())){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte,Este)
    }
}

//a
function hayMotoquerosSinClub(){
    /*
    Proposito: indica si hay motoqueros sin club en la convención
    Precondiciones: Ninguna.
    Tipo: Booleano
    Obs: Es un recorrido de busqueda sobre ubicaciones en la convencion de motoqueros buscando un motoquero sin club asignado.
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte,Este)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Norte,Este)&&not (hayMotoqueroSinClubAcá())){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte,Este)
    }
    return(hayMotoqueroSinClubAcá)
}

function hayMotoqueroSinClubAcá(){
    /*
    Proposito: indica si el motoquero en la ubicacion actual no pertenece a ningún club
    Precondiciones: Ninguna.
    Tipo: Booleano
    */
    return(hayMotoqueroAcá() and not (elMotoqueroPerteneceAUnClub()))
}

//Necesarias para probar que funcione
procedure IncluirEnElClubNúmero_(númeroDeClub){
    repeat(númeroDeClub){
        Poner(Rojo)
    }
}
function hayMotoqueroAcá(){
    return(hayBolitas(Negro))
}
function elMotoqueroPerteneceAUnClub(){
    return(hayBolitas(Rojo))
}
procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
{
 /*
 PROPÓSITO: ir a la primera celda de un recorrido al dirPrincipal y dirSecundaria
 PARÁMETROS:
 * dirPrincipal: Direccion - la direccion principal del recorrido.
 * dirSecundaria: Direccion - la direccion secundaria del recorrido.
 PRECONDICIONES:
 * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
    IrAEsquinaAl_Y_(opuesto(dirPrincipal),opuesto(dirSecundaria))
}
function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal,
dirSecundaria) {
 /*
    PROPÓSITO: indicar si hay una celda siguiente en un recorrido hacia dirPrincipal ,dirSecundaria
    PARÁMETROS:
        * dirPrincipal: Direccion - la direccion principal del recorrido.
        * dirSecundaria: Direccion - la direccion secundaria del recorrido.
    TIPO: booleano
    PRECONDICIONES:
        * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
 return (puedeMover(dirPrincipal)||puedeMover(dirSecundaria))
}
procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal,
dirSecundaria) {
 /*
    PROPÓSITO: ir a la siguiente celda en un recorrido hacia dirPrincipal y dirSecundaria
    PARÁMETROS:
        * dirPrincipal: Direccion - la direccion principal del recorrido.
        * dirSecundaria: Direccion - la direccion secundaria del recorrido.
    PRECONDICIONES:
        * debe haber una celda siguiente en el recorrido
        * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
    if (puedeMover(dirPrincipal)) {
        Mover(dirPrincipal)
    } else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}
procedure IrAEsquinaAl_Y_(primeraDirección,segundaDirección) {
 /*
 PROPÓSITO: ir esquina primeraDirección segundaDirección
 PARÁMETROS:
 * primeraDirección : Direccion - una de los lados de la esquina a la que se desea ir.
 * segundaDirección: Direccion - el otro lado de la esquina que se desea ir.
 PRECONDICIONES:
 * ambos parametros deben ser distintas y no deben ser opuestos
 */

    IrAlBorde(primeraDirección)
    IrAlBorde(segundaDirección)
}


//Mati

procedure IrAPrimerMotoqueroAl_YAl_(primeraDireccion, segundaDireccion) {
    /*
    proposito: se posiciona en el primer motoquero en direccion al "primeraDireccion" y "segundaDireccion"
    precondicion: debe haber al menos un motoquero en la direccion al "primeraDireccion" y al "segundaDireccion"
    parametro:
    primeraDireccion: direccion - primera direccion a la que situa el cabezal
    segundaDireccion: direccion - segunda direccion a la que situa el cabezal
    */

    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte,Este)
}
