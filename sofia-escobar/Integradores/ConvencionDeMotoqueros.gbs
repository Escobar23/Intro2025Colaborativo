program{
    IrHastaElMotoqueroSinClubConVecinoEn_(3)
}

//1 e
procedure IrHastaElMotoqueroSinClubConVecinoEn_(númeroDeClub){
    /*
    Proposito: Indica si en la celda actual hay un motoquero sin club con vecino del club *númeroDeClub*.
    Precondicion: NInguna
    Parametro: númeroDeClub: Número - numero del club del vecino.
    Tipo: Booleano
    Observacion: Es un recorrido de busqueda sabiendo que el motoquero sin club existe, sobre las celdas de la convencion.
    */
     IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte, Este)
    while(not esMotoqueroSinClubConVecinoDeClub_(númeroDeClub)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte, Este)
    }
}

function esMotoqueroSinClubConVecinoDeClub_(númeroDeClub){
    /*
    Proposito: Indica si en la celda actual hay un motoquero sin club con vecino del club *númeroDeClub*.
    Precondicion: NInguna
    Parametro: númeroDeClub: Número - numero del club del vecino.
    Tipo: Booleano
    */
    return(hayMotoqueroAcá() && hayMotoqueroSinClubConVecinoEn_(númeroDeClub))
}

//1 c
procedure AsignarClub_AMotoquerosConectados(númeroDeClub) {
    /*
    Proposito:  Asigna el club con número *númeroDeClub* a todos los motoqueros conectados al motoquero en la celda actual.
    Precondicion: El motoquero de la celda actual no debe pertecener a ningun club.
    Parametro: númeroDeClub: Número - numero del club a asignar.
    Observacion: Es un recorrido de. //duda
    */
     IncluirEnElClubNúmero_(númeroDeClub)
   IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte, Este)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Norte, Este)){
        if(hayMotoqueroAcá() && hayMotoqueroSinClubConVecinoEn_(númeroDeClub)){
            IncluirEnElClubNúmero_(númeroDeClub)
        }
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte, Este)
    }
}

procedure AsignarClub_AlMotoqueroVecino(númeroDeClub){
    /*
    Proposito:  Asigna el club con número *númeroDeClub* al motoquero de la celda actual si tiene de vecino a un motoquero del club *númeroDeClub*.
    Precondicion: El motoquero de la celda actual no debe pertecener a ningun club.
    Parametro: númeroDeClub: Número - numero del club a asignar.
    */
    if(hayMotoqueroSinClubConVecinoEn_(númeroDeClub)){
        IncluirEnElClubNúmero_(númeroDeClub)
    }
}

//1 d
function hayMotoqueroSinClubConVecinoEn_(númeroDeClub){
    /*
    Proposito:  Indica si en la convención hay algún motoquero sin club todavía que tenga de vecino otro motoquero que tenga por club *númeroDeClub*.
    Precondicion: Debe haber un motoquero en la celda actual. //creo q no
    Parametro: númeroDeClub: Número - numero del club a verificar.
    Tipo: Booleano
    Observacion: Es un recorrido de busqueda sin saber si hay un motoquero del club *númeroDeClub* sobre las direcciones vecinas del motoquero actual.
    */
    dirActual:= minDir()
    while(dirActual/=maxDir() && not elMotoqueroDe_PerteneceAlClub_(dirActual, númeroDeClub)){
        dirActual:= siguiente(dirActual)
    }
    return (elMotoqueroDe_PerteneceAlClub_(dirActual, númeroDeClub))
}

function elMotoqueroDe_PerteneceAlClub_(dirAMover, númeroDeClub){
    /*
    Proposito:  Indica si el motoquero en la dirección *dirAMover* pertenece al club con número *númeroDeClub*.
    Precondicion: Ninguna
    Parametro: dirAMover: Dirección - dirección en la que se encuentra el motoquero a verificar.
                númeroDeClub: Número - numero del club a verificar.
    Tipo: Booleano
    */
    return(puedeMover(dirAMover) && esElMotoqueroDel_DelClub_(dirAMover, númeroDeClub))
}

function esElMotoqueroDel_DelClub_(dirAMover, númeroDeClub){
    /*
    Propósito:  Indica si el motoquero en la dirección *dirAMover* pertenece al club con número *númeroDeClub*.
    Precondicion: Debe haber al menos una celda en la dirección *dirAMover*.
    Parametro: dirAMover: Dirección - dirección en la que se encuentra el motoquero a verificar.
                númeroDeClub: Número - numero del club a verificar.
    Tipo: Booleano
    */
    Mover(dirAMover)
    return(hayMotoqueroAcá() && perteneceAlClub_(númeroDeClub))
}


function perteneceAlClub_(númeroDeClub){
    return(nroBolitas(Rojo)==númeroDeClub)
}

//1 b
procedure IrAMotoqueroSinClub() {
    /*
    Proposito:  Mueve el cabezal a la celda del primer motoquero que no tiene club. /// duda
    Precondicion: Existe al menos un motoquero sin club en la convención.
    Parametro: Ninguna
    Observacion: Es un recorrido de busqueda sabiendo que hay un motoquero sin club asignado en la convención.  
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte, Este)
    while(not esMotoqueroSinClub()){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte, Este)
    }
}

//1 a
function hayMotoquerosSinClub() {
    /*
    Proposito:  indica si en la convención hay algún motoquero que todavía no tenga un club.
    Precondicion: Ninguna
    Parametro: Ninguna
    Tipo: Booleano  
    Observacion: Es un recorrido de busqueda sin saber si hay motoquero sin club asignado en la convención.  
    */
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte, Este)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Norte, Este) && not esMotoqueroSinClub()){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte, Este)
    }
    return(esMotoqueroSinClub())
}
function esMotoqueroSinClub(){
    /*
    Proposito:  Indica si el motoquero en la celda actual no pertenece a ningun club.
    Precondicion: Ninguna
    Parametro: Ninguna
    Tipo: Booleano    
    */
    return(hayMotoqueroAcá() && elMotoqueroPerteneceAUnClub())
}
//Necesarias para probar que funcione
procedure IncluirEnElClubNúmero_(númeroDeClub){
    repeat(númeroDeClub){
        Poner(Rojo)
    }
}
function hayMotoqueroAcá(){
    return(hayBolitas(Negro))
}
function elMotoqueroPerteneceAUnClub(){
    return(hayBolitas(Rojo))
}
procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
{
 /*
 PROPÓSITO: ir a la primera celda de un recorrido al dirPrincipal y dirSecundaria
 PARÁMETROS:
 * dirPrincipal: Direccion - la direccion principal del recorrido.
 * dirSecundaria: Direccion - la direccion secundaria del recorrido.
 PRECONDICIONES:
 * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
    IrAEsquinaAl_Y_(opuesto(dirPrincipal),opuesto(dirSecundaria))
}
function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal,
dirSecundaria) {
 /*
    PROPÓSITO: indicar si hay una celda siguiente en un recorrido hacia dirPrincipal ,dirSecundaria
    PARÁMETROS:
        * dirPrincipal: Direccion - la direccion principal del recorrido.
        * dirSecundaria: Direccion - la direccion secundaria del recorrido.
    TIPO: booleano
    PRECONDICIONES:
        * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
 return (puedeMover(dirPrincipal)||puedeMover(dirSecundaria))
}
procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal,
dirSecundaria) {
 /*
    PROPÓSITO: ir a la siguiente celda en un recorrido hacia dirPrincipal y dirSecundaria
    PARÁMETROS:
        * dirPrincipal: Direccion - la direccion principal del recorrido.
        * dirSecundaria: Direccion - la direccion secundaria del recorrido.
    PRECONDICIONES:
        * debe haber una celda siguiente en el recorrido
        * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
    if (puedeMover(dirPrincipal)) {
        Mover(dirPrincipal)
    } else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}
procedure IrAEsquinaAl_Y_(primeraDirección,segundaDirección) {
 /*
 PROPÓSITO: ir esquina primeraDirección segundaDirección
 PARÁMETROS:
 * primeraDirección : Direccion - una de los lados de la esquina a la que se desea ir.
 * segundaDirección: Direccion - el otro lado de la esquina que se desea ir.
 PRECONDICIONES:
 * ambos parametros deben ser distintas y no deben ser opuestos
 */

    IrAlBorde(primeraDirección)
    IrAlBorde(segundaDirección)
}
