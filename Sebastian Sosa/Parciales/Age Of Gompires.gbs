// Primitivas 

function recursoMadera(){
    /*
    PROPOSITO: Describe el color con el que se representa el recurso "madera"
    TIPO: Color
    PRECONDICIONES: Ninguna.
    */
}

function recursoPiedra(){
    /*
    PROPOSITO: Describe el color con el que se representa el recurso "piedra"
    TIPO: Color
    PRECONDICIONES: Ninguna
    */
}

function recursoOro(){
    /*
    PROPOSITO: Describe el color con el que se representa el recurso "oro
    TIPO: Color
    PRECONDICIONES: Ninguna
    */
}

function recursoAlimento(){
    /*
    PROPOSITO: Describe el color con el que se representa el recurso "alimento"
    TIPO: Color
    PRECONDICIONES: Ninguna
    */
}

function minRecurso(){
    /*
    PROPOSITO: Describe el primero de los recursos
    TIPO: Color
    PRECONDICIONES: Ninguna 
    */
}

function maxRecurso(){
    /*
    PROPOSITO: Describe el ultimo de los recursos       
    TIPO: Color 
    PRECONDICIONES: Ninguna
    */
}

function siguienteRecursoAcá(recurso){
    /*
    PROPOSITO: Describe el recurso siguiente a **recurso**
    PARAMETROS: -*recurso*: Color - recurso para el cuál se describe su siguiente
    TIPO: Color
    PRECONDICIONES: Ninguna
    */
}

function hayRecursoAcá(recurso){
    /*
    PROPOSITO: Indica si hay unidades del recurso **recurso** en la parcela actual      
    PRECONDICION: Ninguna
    PARAMETROS: -*recurso*: Color - color que representa el recurso para el cual se indica si hay en la parcela actual
    TIPO: Booleano    
    */
}

procedure IncrementarRecurso_Acá(recurso){
    /*
    PROPOSITO: Incrementar en 1 las unidades del recurso **recurso** en la parcela actual.
    PARAMETROS: -*recurso*: Color - color que representa el recurso a incrementar
    PRECONDICION: Ninguna
    */
}

procedure DecrementarRecurso_Acá(recurso){
    /*
    PROPOSITO: Decrementar en 1 la cantidad del recurso *recurso* en la parcela actual
    PARÁMETROS: -*recurso*: Color - color que represeta el recurso a decrementar
    PRECONDICIONES: - Debe haber al menos una unidad del recurso **recurso** en la parcela actual
    */
}

function intensidadDelRecurso_Acá(recurso){
    /*
    PROPOSITO: Describe la cantidad de unidades del recurso **recurso** de la parcela actual.
    PARÁMETROS: -*recurso*: Color - color que representa el recurso a determinar sus unidades.
    PRECONDICION: Ninguna
    Tipo: Número
    */
}
//BIIBLIOTECA---------------------------------------------------------------------
procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
{
 /*
 PROPÓSITO: ir a la primera celda de un recorrido al dirPrincipal y dirSecundaria
 PARÁMETROS:
 * dirPrincipal: Direccion - la direccion principal del recorrido.
 * dirSecundaria: Direccion - la direccion secundaria del recorrido.
 PRECONDICIONES:
 * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
    IrAEsquinaAl_Y_(opuesto(dirPrincipal),opuesto(dirSecundaria))
}
procedure IrAEsquinaAl_Y_(primeraDirección,segundaDirección) {
 /*
 PROPÓSITO: ir esquina primeraDirección segundaDirección
 PARÁMETROS:
 * primeraDirección : Direccion - una de los lados de la esquina a la que se desea ir.
 * segundaDirección: Direccion - el otro lado de la esquina que se desea ir.
 PRECONDICIONES:
 * ambos parametros deben ser distintas y no deben ser opuestos
 */

    IrAlBorde(primeraDirección)
    IrAlBorde(segundaDirección)
}

function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal,
dirSecundaria) {
 /*
    PROPÓSITO: indicar si hay una celda siguiente en un recorrido hacia dirPrincipal ,dirSecundaria
    PARÁMETROS:
        * dirPrincipal: Direccion - la direccion principal del recorrido.
        * dirSecundaria: Direccion - la direccion secundaria del recorrido.
    TIPO: booleano
    PRECONDICIONES:
        * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
 return (puedeMover(dirPrincipal)||puedeMover(dirSecundaria))
}

procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal,
dirSecundaria) {
 /*
    PROPÓSITO: ir a la siguiente celda en un recorrido hacia dirPrincipal y dirSecundaria
    PARÁMETROS:
        * dirPrincipal: Direccion - la direccion principal del recorrido.
        * dirSecundaria: Direccion - la direccion secundaria del recorrido.
    PRECONDICIONES:
        * debe haber una celda siguiente en el recorrido
        * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
    if (puedeMover(dirPrincipal)) {
        Mover(dirPrincipal)
    } else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}
//BIIBLIOTECA---------------------------------------------------------------------


// Ejercicio 1)

function puntosAObtenerEnSector(){
    /*
    PROPOSITO: Devuelve la cantidad de puntos a obtener en el sector actual
    PRECONCICION: Ninguna
    TIPO: Número
    */
    return((puntos_AObtenerSiHay_0_(15, recursoOro(), recursoAlimento())) + (puntos_aObtenerSiHay_0_(10, recursoPiedra(), recursoMadera())) + (puntosAObtenerSiHayTodosLosRecursos())) 

}

function puntos_AObtenerSiHay_0_(puntos, recurso1, recurso2){
    /*
    PROPOSITO: Describe la cantidad de puntos **puntos** a obtener si en el sector actual hay recursos **recurso1** o **recurso2** 
    PRECONCICION: Ninguna
    TIPO: Número
    */
    return(choose puntos when (hayRecurso_EnElSector(recurso1) || hayRecurso_EnElSector(recurso2)) 0 otherwise)
}

function puntosAObtenerSiHayTodosLosRecursos(){
    /*
    PROPOSITO:
    PRECONDICIONES:
    TIPO:
    */
    return(choose 10 when ((hayRecurso_EnElSector(recursoOro())) && (hayRecurso_EnElSector(recursoAlimento())) && (hayRecurso_EnElSector(recursoMadera())) && (hayRecurso_EnElSector(recursoPiedra()))))
}

function hayRecurso_EnElSector(recurso){
    /*
    PROPOSITO: Indica si hay el recurso **recurso** en el sector actual.   
    PRECONDICION: Ninguna
    TIPO: Booleano
    OBSERVACIONES: Es un recorrido de busqueda sobre parcelas sin saber si el recurso **recurso** está.
    */
    direcciónActual := minDir()
    while(puedeMover(direcciónActual) && (not(hayRecursoAcá(recurso)))){
        Mover(direcciónActual)
        direcciónActual := siguiente(direcciónActual)
    }
    return(hayRecursoAcá(recurso))
}

//Ejercicio 2)


