Basados en este modelo y asumiendo en todos los casos que sobre el tablero hay un mapa de Age of Gompire bien representado, se pide:
Ejercicio 1)
    El puntaje que obtiene un jugador tiene que ver con el concepto de "sector", que refiere a la parcela donde se ubica el cabezal (parcela actual) y todas las parcelas vecinas de manera ortogonal (hacia cada una de las direcciones). En ese sentido, los puntajes obtenidos tienen que ver con saber qué recursos hay disponibles en la totalidad del sector, siguiendo las reglas:
    .
    Se obtienen 15 puntos si en el sector hay oro, o si hay alimento (solo 15 por cualquiera de los dos, no 15 por cada uno).
    Se obtienen 10 puntos si en el sector hay piedra, o si hay madera (solo 10 por cualquiera de los dos, no 15 por cada uno).
    Se obtienen 10 puntos adicionales si hay de los 4 tipos de recursos en el sector.
    Se pide que escriba la función puntosAObtenerEnSector() que describe los puntos obtenidos en el sector centrado en la parcela actual.
Ejercicio 2)
    Para recompensar a los jugadores que han pasado varias horas de juego, "Age of Gompire" tiene el criterio de aumentar las cantidades del recurso de menor riqueza en una cantidad variable. Para modelar este comportamiento, se pide implementar el procedimiento AumentarEn_RecursoDeMenorRiqueza que, dado un número que representa la cantidad en la cual aumentar el recurso, aumenta cada parcela que contenga al menos una unidad del recurso de menor riqueza en todo el mapa tantas unidades como el número dado.
Ejercicio 3)
    El juego también sigue criterios para penalizar a algunos jugadores, penalizando parcelas específicas. La forma de penalizar consiste en eliminar todas las unidades de oro que hubiera en la parcela, y restar 15 unidades de todos los otros recursos.

    Considere la siguiente implementación de PenalizarParcelaActual(), y asuma la existencia del procedimiento DejarParcelaCon_Oro_Madera_PiedraY_Alimento que, dados cuatro números mayores o iguales a cero, y como su nombre sugiere, deja la parcela actual con exactamente tantas unidades de cada correcto recurso como el número correspondiente dado.

// Primitivas 

function recursoMadera(){
    /*
    PROPOSITO: Describe el color con el que se representa el recurso "madera"
    TIPO: Color
    PRECONDICIONES: Ninguna.
    */
}

function recursoPiedra(){
    /*
    PROPOSITO: Describe el color con el que se representa el recurso "piedra"
    TIPO: Color
    PRECONDICIONES: Ninguna
    */
}

function recursoOro(){
    /*
    PROPOSITO: Describe el color con el que se representa el recurso "oro
    TIPO: Color
    PRECONDICIONES: Ninguna
    */
}

function recursoAlimento(){
    /*
    PROPOSITO: Describe el color con el que se representa el recurso "alimento"
    TIPO: Color
    PRECONDICIONES: Ninguna
    */
}

function minRecurso(){
    /*
    PROPOSITO: Describe el primero de los recursos
    TIPO: Color
    PRECONDICIONES: Ninguna 
    */
}

function maxRecurso(){
    /*
    PROPOSITO: Describe el ultimo de los recursos       
    TIPO: Color 
    PRECONDICIONES: Ninguna
    */
}

function siguienteRecursoAcá(recurso){
    /*
    PROPOSITO: Describe el recurso siguiente a **recurso**
    PARAMETROS: -*recurso*: Color - recurso para el cuál se describe su siguiente
    TIPO: Color
    PRECONDICIONES: Ninguna
    */
}

function hayRecursoAcá(recurso){
    /*
    PROPOSITO: Indica si hay unidades del recurso **recurso** en la parcela actual      
    PRECONDICION: Ninguna
    PARAMETROS: -*recurso*: Color - color que representa el recurso para el cual se indica si hay en la parcela actual
    TIPO: Booleano    
    */
}

procedure IncrementarRecurso_Acá(recurso){
    /*
    PROPOSITO: Incrementar en 1 las unidades del recurso **recurso** en la parcela actual.
    PARAMETROS: -*recurso*: Color - color que representa el recurso a incrementar
    PRECONDICION: Ninguna
    */
}

procedure DecrementarRecurso_Acá(recurso){
    /*
    PROPOSITO: Decrementar en 1 la cantidad del recurso *recurso* en la parcela actual
    PARÁMETROS: -*recurso*: Color - color que represeta el recurso a decrementar
    PRECONDICIONES: - Debe haber al menos una unidad del recurso **recurso** en la parcela actual
    */
}

function intensidadDelRecurso_Acá(recurso){
    /*
    PROPOSITO: Describe la cantidad de unidades del recurso **recurso** de la parcela actual.
    PARÁMETROS: -*recurso*: Color - color que representa el recurso a determinar sus unidades.
    PRECONDICION: Ninguna
    Tipo: Número
    */
}
//BIIBLIOTECA---------------------------------------------------------------------
procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
{
 /*
 PROPÓSITO: ir a la primera celda de un recorrido al dirPrincipal y dirSecundaria
 PARÁMETROS:
 * dirPrincipal: Direccion - la direccion principal del recorrido.
 * dirSecundaria: Direccion - la direccion secundaria del recorrido.
 PRECONDICIONES:
 * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
    IrAEsquinaAl_Y_(opuesto(dirPrincipal),opuesto(dirSecundaria))
}
procedure IrAEsquinaAl_Y_(primeraDirección,segundaDirección) {
 /*
 PROPÓSITO: ir esquina primeraDirección segundaDirección
 PARÁMETROS:
 * primeraDirección : Direccion - una de los lados de la esquina a la que se desea ir.
 * segundaDirección: Direccion - el otro lado de la esquina que se desea ir.
 PRECONDICIONES:
 * ambos parametros deben ser distintas y no deben ser opuestos
 */

    IrAlBorde(primeraDirección)
    IrAlBorde(segundaDirección)
}

function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal,
dirSecundaria) {
 /*
    PROPÓSITO: indicar si hay una celda siguiente en un recorrido hacia dirPrincipal ,dirSecundaria
    PARÁMETROS:
        * dirPrincipal: Direccion - la direccion principal del recorrido.
        * dirSecundaria: Direccion - la direccion secundaria del recorrido.
    TIPO: booleano
    PRECONDICIONES:
        * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
 return (puedeMover(dirPrincipal)||puedeMover(dirSecundaria))
}

procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal,
dirSecundaria) {
 /*
    PROPÓSITO: ir a la siguiente celda en un recorrido hacia dirPrincipal y dirSecundaria
    PARÁMETROS:
        * dirPrincipal: Direccion - la direccion principal del recorrido.
        * dirSecundaria: Direccion - la direccion secundaria del recorrido.
    PRECONDICIONES:
        * debe haber una celda siguiente en el recorrido
        * dirPrincipal y dirSecundaria no deben ser opuestas ni iguales
 */
    if (puedeMover(dirPrincipal)) {
        Mover(dirPrincipal)
    } else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}
//BIIBLIOTECA---------------------------------------------------------------------


// Ejercicio 1)

function puntosAObtenerEnSector(){
    /*
    PROPOSITO: Devuelve la cantidad de puntos a obtener en el sector actual
    PRECONCICION: Ninguna
    TIPO: Número
    */
    return((puntos_AObtenerSiHay_0_(15, recursoOro(), recursoAlimento())) + (puntos_aObtenerSiHay_0_(10, recursoPiedra(), recursoMadera())) + (puntosAObtenerSiHayTodosLosRecursos())) 

}

function puntos_AObtenerSiHay_0_(puntos, recurso1, recurso2){
    /*
    PROPOSITO: Describe la cantidad de puntos **puntos** a obtener si en el sector actual hay recursos **recurso1** o **recurso2** 
    PRECONCICION: Ninguna
    TIPO: Número
    */
    return(choose puntos when (hayRecurso_EnElSector(recurso1) || hayRecurso_EnElSector(recurso2)) 0 otherwise)
}

function puntosAObtenerSiHayTodosLosRecursos(){
    /*
    PROPOSITO:
    PRECONDICIONES:
    TIPO:
    */
    return(choose 10 when ((hayRecurso_EnElSector(recursoOro())) && (hayRecurso_EnElSector(recursoAlimento())) && (hayRecurso_EnElSector(recursoMadera())) && (hayRecurso_EnElSector(recursoPiedra()))))
}

function hayRecurso_EnElSector(recurso){
    /*
    PROPOSITO: Indica si hay el recurso **recurso** en el sector actual.   
    PRECONDICION: Ninguna
    TIPO: Booleano
    OBSERVACIONES: Es un recorrido de busqueda sobre parcelas sin saber si el recurso **recurso** está.
    */
    direcciónActual := minDir()
    while(puedeMover(direcciónActual) && (not(hayRecursoAcá(recurso)))){
        Mover(direcciónActual)
        direcciónActual := siguiente(direcciónActual)
    }
    return(hayRecursoAcá(recurso))
}

//Ejercicio 2)

procedure AumentarEn_RecursoDeMenorRiqueza(númeroAAumentar){
    /*
    PROPOSITO: Aumenta en **númeroAAumentar** el recurso de menor riqueza 
    PRECONDICIONES: Ninguna 
    OBSERVACIONES: Es un recorrido de transformación sobre parcelas, aumentando en *númeroAAumentar* los recursos de menor riqueza.    
    */
    IrAPrimerParcela()
    while(haySiguienteParcela()){
        AumentarEn_AlRecurso_(númeroAAumentar, recursoDeMenorRiqueza)
        IrASiguienteParcela()
    }
    AumentarEn_AlRecurso_Acá(númeroAAumentar, recursoDeMenorRiqueza)
}

procedure AumentarEn_AlRecurso_(número, recurso){
    /*
    PROPOSITO: Aumenta en *número* a la cantidad del recurso **recurso**
    PRECONDICIONES: Ninguna 
    PARAMETROS: *número : Numero - la cantidad del recurso a aumentar
                *recurso: Color - el recurso a aumentar
    */
    if(hayRecurso_Aca(recurso)){
        
    }
}